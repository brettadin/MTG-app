MTG?app Architectural & Quality Review
1 Overview of the repository and its goals
The MTG?app repository is an ambitious attempt to build a unified desktop application for Magic: The Gathering players. It serves as a card search engine, deck builder/importer/exporter, statistics analyser and a fully?playable game engine with visual effects and AI opponents. The project consists of approximately 18?350 lines of code across about 30 systems and uses Python 3.11, PySide6 for the GUI, SQLite for local card storage, and pulls card data from MTGJSON and images from Scryfall[1].
The README and the feature summary document describe a very broad feature set: complete rules implementation (priority system, mana system, phases, stack), visual effects, deck analysis tools, quick search, theme system, keyboard shortcuts, deck import/export in multiple formats, pricing and legality tracking, drag?and?drop UI, collection tracking, commander support and multiplayer modes[2][3]. The core game engine resides under app/game/; user?interface components live in app/ui/; analysis tools (deck analyser, synergy finder, etc.) live in app/utils/; database access and services are in app/data_access and app/services; and documentation lives under doc/[4]. The main entry point is main.py which configures logging, checks for the card database and launches a monolithic IntegratedMainWindow[5].
2 High?level architectural observations
Modular decomposition
The project attempts to separate concerns: game rules in app/game, UI in app/ui, utilities in app/utils, persistent data in app/data_access, and domain services in app/services. The session summary emphasises a modular, testable architecture with clear separation of logic vs UI and an event?driven design[6]. However, as more features have been “dumped in” without consolidation or testing, several modules have become monolithic and tightly coupled:
* The IntegratedMainWindow is almost 1 000 lines long and instantiates dozens of feature managers, services and UI widgets in its constructor[7][8]. This makes it difficult to reason about or test individual features.
* Many service classes are created directly inside the main window (DeckService, FavoritesService, ImportExportService, CollectionTracker, RecentCardsTracker, etc.)[9][10] rather than being injected via a dependency?injection mechanism.
* The game engine imports optional systems (priority, mana, phases, etc.) via try/except and disables functionality if imports fail[11]. This “graceful degradation” is useful, but it can hide integration errors and makes it harder to know whether the full rule set is active.
* Data access, models and UI still intermingle in certain files. For example, the deck builder UI calls directly into the database when performing searches or deck operations, bypassing service layers[12].
Documentation and session notes
A major strength of this repository is its extensive documentation. Each session summary outlines what was built and provides architectural diagrams[13]. The Integration Guide details how to wire new features like theme switching, symbol fonts and keyboard shortcuts into the main window[14]. The Feature Summary lists each completed component, its files and key functions[15][16]. This level of documentation is valuable; however, developers must commit to keeping it current whenever code changes occur. Out?of?date docs risk misleading the next developer or the AI agent working on the code.
Code quality and testing
Little evidence exists of automated tests. None of the modules include test suites or CI workflows to run them. As the README admits, features have been “dumped in” without actual testing or bug fixing. Complex systems like the game engine, deck importer and visual effects are therefore likely to contain hidden bugs. Using type hints and dataclasses is a positive step, but static type checking (e.g., mypy) is not enforced. Without unit tests, integration tests and continuous integration, the risk of regression grows with each added feature.
External inspiration
The README lists similar open?source projects such as mtgatool?desktop, MtgDesktopCompanion, Scrython and Cockatrice[17]. These projects implement deck tracking, collection browsing, card parsing and fully playable matches. Examining their architectures can provide useful patterns (e.g., plugin systems, separation between rules engine and UI, networked play support). For example, mtgatool?desktop describes itself as a collection viewer, deck tracker and statistics manager[18]—features overlapping with this project. Mtgdb.Gui is another open?source deck builder and search engine[19]. Referencing how those projects organise their services, UI and data models can help drive improvements in this code base.
3 Potential problems and recommendations
3.1 Game engine and rules system
* Simplified mana and state checking. The current mana pool implementation in Player simply deducts any mana when paying a cost[20] and the engine uses a rudimentary check total_mana > 0[21]. This will allow illegal spell casting. The detailed ManaManager in mana_system.py supports full mana cost parsing[22]—the engine should delegate to this rather than the simplistic fallback. Ensure that deck construction and gameplay always use the full mana system.
* Missing stack resolution and targeting logic. Many methods in GameEngine are placeholders: declare_attackers_step, declare_blockers_step, combat_damage_step and resolve_stack_top log messages but do not implement real combat or spell resolution[23][24]. Interaction with StackManager, TargetingSystem and CombatManager should be completed and thoroughly tested. Use the MTG Comprehensive Rules as a reference.
* State?based actions & triggers. The fallback SBA checker kills creatures with lethal damage or zero toughness and checks game?loss conditions[25], but the full StateBasedActionsChecker referenced in docs has many more conditions. Integration of triggers and SBA should be verified via test games.
* AI opponent. The IntegratedMainWindow instantiates AIOpponent but does not show how decisions are made. Without state evaluation, AI may behave randomly or crash. Look at existing AI implementations (e.g., Mulligan decisions or mtga?bot) for heuristics.
* Game replay & persistence. The README lists game replay and auto?save features[26], but there is no sign of persistence or serialization in the code. Decide on a format (JSON, YAML) to record game states and actions so that replays and checkpoints are possible.
3.2 Deck builder and search engine
* Database indexing. Searching by name, text and other attributes needs efficient indexes. The build script scripts/build_index.py creates data/mtg_index.sqlite, but there is no mention of indexing columns or using full?text search (FTS). Consider using SQLite FTS5 or an external search library like Whoosh or ElasticSearch to handle fuzzy queries.
* Handling of card variants and printings. The search results show multiple printings and alternative arts[27]. Ensure that the data model distinguishes between card faces, tokens and reprints. Use Scryfall’s collector_number and set_code fields when importing decks.
* Deck validation. The validation system checks deck size, card limits and format legality[28]. Make sure it supports commander rules (singleton + colour identity), special cards like Persistent Petitioners, and banned lists. Provide an up?to?date banned cards list and test it.
* Import/export robustness. The DeckImporter parses MTGO, Arena, text and CSV formats[29]. There are potential edge cases: unusual whitespace, Unicode, set names with hyphens, sideboards labeled SB: vs Sideboard, or Arena exports with card names containing parentheses. Add extensive unit tests with real deck files, including error cases, and provide meaningful error messages.
* Performance of search and UI. Loading the full MTG database (~2 GB) may cause long startup times. Use asynchronous loading, show progress indicators and avoid blocking the UI thread when performing searches or image downloads.
3.3 User interface and UX
* Monolithic window class. The IntegratedMainWindow should be decomposed into smaller widgets or controllers. Each tab (Deck Builder, Collection, Statistics, Game) could be its own class with its own state and signals, adhering to an MVC/MVP pattern. Introduce a plugin or extension system so new features can be registered without modifying the main window.
* Asynchronous operations. Network operations (image download from Scryfall, price updates) should be performed in background threads or using QThreadPool/QtConcurrent to avoid freezing the UI. The price tracker and scryfall client currently run synchronously and may block[9].
* Accessibility and themes. Ensure high contrast and colour?blind friendly themes. Provide tooltips and keyboard navigation for all UI elements. The theme manager supports dark/light modes[30], but further accessibility testing is recommended.
* State persistence. Remember UI settings and the last opened deck between sessions. The settings dialog stores user preferences in YAML[31]; verify that preferences are loaded and saved correctly.
* Error feedback. When the card database is missing, the application prints a warning and exits[32]. Provide a GUI prompt explaining how to build the index rather than failing silently. Similarly, when deck import fails, show a detailed message with line numbers and suggestions.
3.4 Data access and services
* Repository & service pattern. The code uses Database, MTGRepository, DeckService, etc., but many components still access the database directly. Create repository classes for each domain entity (Card, Deck, Collection) and inject them into services and UI components via dependency injection. This isolation will facilitate unit testing and future changes (e.g., migrating to a different DB engine).
* Concurrency safety. SQLite is not fully thread?safe. If multiple threads (UI + background workers) access the database concurrently, use connection pooling or a single shared connection with a mutex.
* Caching strategy. Card images and API responses should be cached locally to avoid repeated network requests[33]. Provide configuration for cache size and eviction policy[34].
* Logging. The application uses a setup_logging function to configure rotating log files[35]. Verify that log levels are appropriate (INFO for normal operations, DEBUG for verbose output) and consider logging to the OS logging service on macOS or Windows. Include error handling and stack traces in logs.
3.5 Documentation & maintenance
* Keep documentation in sync. Each new feature must update the Feature Summary, Integration Guide, Quick Start Guide and session summaries. The integration guide shows example code for hooking features into the main window[36]. If a developer modifies the API of a feature, update the guide immediately to avoid confusion.
* Cross?reference external sources. When implementing new features, consult open?source projects like mtgatool?desktop, MtgDesktopCompanion and Cockatrice for inspiration. Document any borrowed ideas in reference_links.md (already referenced in the README[17]) and provide attribution. This helps future developers understand the design rationale.
* Add a CONTRIBUTING guide. Describe coding standards (PEP 8), branch naming conventions, how to run tests and build the index, and how to update documentation. This will help human contributors and AI agents work consistently.
3.6 Testing & continuous integration
* Unit tests. Write unit tests for each module: deck importer, mana parsing, trigger conditions, deck validator, UI interactions (using pytest-qt), etc. Include edge cases like empty decks, illegal mana costs and invalid file formats.
* Integration tests. Develop automated test scenarios that simulate playing a game: create players, shuffle and draw, cast spells, resolve the stack, check life totals and poison counters, and verify game end conditions. Test UI workflows such as building a deck, validating it, importing a deck and exporting to different formats.
* Continuous integration. Set up a CI pipeline (GitHub Actions) that installs dependencies, builds the MTG index (with a small sample dataset), runs tests, performs static type checking with mypy and lints the code with flake8. This will catch errors early and ensure contributions do not break existing functionality.
* Automated packaging. Use tools like PyInstaller or Briefcase to build distributable executables for Windows/Mac/Linux and run smoke tests on them.
4 Summary of actionable improvements
1. Refactor the main window into modular sub?components and adopt an MVC/MVP or plugin?based architecture to reduce coupling and improve testability.
2. Integrate and complete the full game engine by wiring PrioritySystem, ManaManager, PhaseManager, StackManager, CombatManager and StateBasedActionsChecker into the GameEngine. Replace the simplified mana checks with calls to ManaManager[22] and implement real stack resolution and targeting.
3. Enhance the deck importer/exporter with robust parsing and error reporting. Write unit tests using a variety of real deck files to detect edge cases[29]. Support additional formats (e.g., Arena .csv exports, MTG Goldfish lists).
4. Improve search performance by creating proper indexes in SQLite or using an external search library. Ensure fuzzy search and auto?complete work smoothly without blocking the UI.
5. Implement asynchronous operations for network requests (Scryfall images, price tracker, updates) and long?running computations (index building, deck validation) to keep the GUI responsive.
6. Develop a comprehensive test suite and CI pipeline. Use pytest, pytest?qt, mypy and flake8 to ensure code quality. Write integration tests for game play and UI workflows.
7. Strengthen error handling and logging. Provide user?friendly dialogs for missing databases or import failures, and ensure errors are logged with sufficient detail.
8. Establish a documentation update process. For every new feature or change, update the appropriate docs and reference external inspiration sources. Add a CONTRIBUTING.md describing how to add new modules, update docs and run tests.
9. Study similar projects (mtgatool?desktop, MtgDesktopCompanion, Cockatrice, Mtgdb.Gui) for best practices in card data handling, deck tracking and UI design[18][19]. Adopt proven patterns such as plugin architectures, separate process for the game engine, or networked play support.
5 Conclusion
The MTG?app repository is a promising foundation for a full?featured Magic: The Gathering application. It already boasts a vast feature set, modular documentation and a growing game engine. However, because features have been added quickly without comprehensive integration or testing, there are likely many bugs and architectural weaknesses. By refactoring the UI, completing unfinished systems, implementing robust data handling, adding tests and continuous integration, and learning from similar open?source tools, this project can become a stable and maintainable application. The extensive documentation should be maintained as the single source of truth, and every new change should update it accordingly to support both human developers and AI agents working on the codebase.

[1] [2] [3] [4] [17] [26] [27] [33] GitHub - brettadin/MTG-app: i wanted to make a mtg card search/display app. itll probably be similar to the spectra app, so maybe i can reuse some assets from that. we'll see lol.
https://github.com/brettadin/MTG-app
[5] [32] [35] raw.githubusercontent.com
https://raw.githubusercontent.com/brettadin/MTG-app/main/main.py
[6] [13] [22] raw.githubusercontent.com
https://raw.githubusercontent.com/brettadin/MTG-app/main/doc/SESSION_5_SUMMARY.md
[7] [8] [9] [10] raw.githubusercontent.com
https://raw.githubusercontent.com/brettadin/MTG-app/main/app/ui/integrated_main_window.py
[11] [20] [21] [23] [24] [25] raw.githubusercontent.com
https://raw.githubusercontent.com/brettadin/MTG-app/main/app/game/game_engine.py
[12] [14] [36] raw.githubusercontent.com
https://raw.githubusercontent.com/brettadin/MTG-app/main/doc/INTEGRATION_GUIDE.md
[15] [16] [28] [30] [31] [34] raw.githubusercontent.com
https://raw.githubusercontent.com/brettadin/MTG-app/main/doc/FEATURE_SUMMARY.md
[18] GitHub - mtgatool/mtgatool-desktop
https://github.com/mtgatool/mtgatool-desktop
[19] GitHub - NikolayXHD/Mtgdb: Mtgdb.Gui - desktop app to search MTG cards and build decks
https://github.com/NikolayXHD/Mtgdb
[29] raw.githubusercontent.com
https://raw.githubusercontent.com/brettadin/MTG-app/main/app/utils/deck_importer.py
